# -*- coding: utf-8 -*-
"""Mehmet_Ortacebin_Sayisal_Goruntu_Isleme_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yRdT_Xe3xFnBukttBiJJ98IK-FTbwncD

ÜSKÜDAR ÜNİVERSİTESİ - YÜKSEK LİSANS YAPAYAY ZEKA MÜHENDİSLİĞİ (TEZLİ)

Ders: Sayısal Görüntü İşleme

Ödev: Final

Öğrenci: Mehmet Ortacebin

# 1.	Kütüphanelerin İçe Aktarılması
o	Veri işleme için pandas, sayısal işlemler için numpy, opencv ve skimage görselleştirme için matplotlib ve seaborn kütüphanelerini içe aktarın.
o	Ayrıca os modülünü kullanarak dosya yolunu belirtin.
"""

from google.colab import drive
import pandas as pd
import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
import seaborn as sns
from skimage import io

# Google Drive'ı bağlama
drive.mount('/content/drive')

data_path = '/content/drive/MyDrive/ColabNotebooks/SayisalGoruntuIsleme/Final/test'

pneumonia_path = os.path.join(data_path, 'PNEUMONIA')
normal_path = os.path.join(data_path, 'NORMAL')

pneumonia_images = [os.path.join(pneumonia_path, img) for img in os.listdir(pneumonia_path) if img.endswith('.jpeg')]
normal_images = [os.path.join(normal_path, img) for img in os.listdir(normal_path) if img.endswith('.jpeg')]

# Toplam görüntü sayısı
print(f"PNEUMONIA Klasöründeki Görüntü Sayısı: {len(pneumonia_images)}")
print(f"NORMAL Klasöründeki Görüntü Sayısı: {len(normal_images)}")

"""# 2. Görüntü Yükleme ve Görselleştirme
1.	Rastgele Görüntüler Seçme
o	train_df içindeki "Image" sütunundan rastgele 9 görüntü seçin.
o	Bu görüntüleri yan yana görselleştirerek veri setindeki örnek görüntüleri inceleyin.
________________________________________

"""

import random

random.seed(42)

sampled_images = random.sample(pneumonia_images, 4) + random.sample(normal_images, 5)
random.shuffle(sampled_images)

print("Seçilen Görüntüler:")
for img_path in sampled_images:
    print(img_path)

# Görselleştirme
fig, axes = plt.subplots(3, 3, figsize=(12, 12))

for i, ax in enumerate(axes.flatten()):
    img_path = sampled_images[i]
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    category = "PNEUMONIA" if "PNEUMONIA" in img_path else "NORMAL"

    # Görseli ekrana çiz
    ax.imshow(img, cmap='gray')
    ax.set_title(category, fontsize=12)
    ax.axis("off")

plt.tight_layout()
plt.show()

"""# 3. Görüntü İşleme ve İyileştirme (Pre-processing)
1.	Görüntüleri Akciğer bölgeleri kaybolmayacak şekilde kenarlardan kırpın (Crop),(ilgi alanı dışındaki gürültü bölgelerinden kurtulun
o	Orijinal ve Crop edilmiş görüntüleri görseleştirin.
2.	Arasınav ödevi çıktılarını inceleyerek Kontrast Germe (Stretching) Histogram Eşitleme (Equalization) yöntemlerinden uygun gördüğünüzü crop edilmiş görüntüye uygulayın. (YORUM)
o	Crop edilmişve dönüşüme uğramış  görüntüleri görseleştirin.

3.	Bir önceki adımın çıktısına gürültü azaltma işlemlerinden birini seçerek uygulayın (örn: Median ve Gaussian Blur).
o	Görüntüleri görseleştirin

"""

import cv2
import random
import matplotlib.pyplot as plt

def crop_image(image):
    """
    Görüntüyü kenarlardan %10 kırpar.
    """
    height, width = image.shape
    return image[int(height * 0.1):int(height * 0.9), int(width * 0.1):int(width * 0.9)]

# Rastgele 9 görüntü seçme
random.seed(42)
sample_images = random.sample(pneumonia_images, 5) + random.sample(normal_images, 4)
random.shuffle(sample_images)

# Görüntüleri yükleyip kırpma işlemi
original_cropped_pairs = [(cv2.imread(img_path, cv2.IMREAD_GRAYSCALE), crop_image(cv2.imread(img_path, cv2.IMREAD_GRAYSCALE))) for img_path in sample_images]

# Görselleştirme
fig, axes = plt.subplots(9, 2, figsize=(10, 38))

for i, (orig, cropped) in enumerate(original_cropped_pairs):
    axes[i, 0].imshow(orig, cmap='gray')
    axes[i, 0].set_title(f"Orijinal {i+1}")
    axes[i, 0].axis("off")

    axes[i, 1].imshow(cropped, cmap='gray')
    axes[i, 1].set_title(f"Kırpılmış {i+1}")
    axes[i, 1].axis("off")

plt.tight_layout()
plt.show()

"""
Görüntü işleme ve iyileştirme (pre-processing) aşamasında yapılan kırpma işlemi, genellikle görüntüdeki gereksiz bölgeleri kaldırarak, sadece ilgilenilen alanı daha belirgin hale getirmeyi amaçlar. Özellikle tıbbi görüntülerde, örneğin akciğer röntgenlerinde, kenar kısımlarında hasta bilgileri, tarayıcı işaretleri veya boş alanlar olabilir. Bu tür gereksiz bölümler, modelin doğru şekilde öğrenmesini zorlaştırabilir. Kırpma işlemi ile sadece akciğer bölgesi odaklanarak, modelin daha verimli ve doğru şekilde çalışması sağlanır. Ayrıca, görüntüdeki gereksiz kısımların kaldırılması, hesaplama yükünü azaltır ve işlem süresini kısaltır. Görüntüdeki ilgisiz bölgeler çıkarıldığında, model yalnızca önemli verilere odaklanır. Kenarlardan kırpma işlemi, verilerin tutarlılığını artırarak, özellikle farklı kaynaklardan gelen görüntülerdeki veri tutarsızlıklarını azaltır. Bu işlem, tıbbi görüntü analizi, nesne tanıma ve derin öğrenme gibi uygulamalarda kritik bir adımdır."""

# Kontrast Germe (Stretching)
def contrast_stretching(image):
    min_val, max_val = image.min(), image.max()
    stretched = ((image - min_val) / (max_val - min_val) * 255).astype('uint8')
    return stretched

# Histogram Eşitleme (Equalization)
def histogram_equalization(image):
    return cv2.equalizeHist(image)

# Kontrast Germe ve Histogram Eşitleme uygulanmış görüntüleri oluştur
processed_images = [(cropped, contrast_stretching(cropped), histogram_equalization(cropped)) for _, cropped in original_cropped_pairs]

# Görselleştirme
fig, axes = plt.subplots(9, 3, figsize=(15, 38))  # 9 satır, 3 sütun (Kırpılmış, Kontrast Germe, Histogram Eşitleme)

for i, (cropped, stretched, equalized) in enumerate(processed_images):
    axes[i, 0].imshow(cropped, cmap='gray')
    axes[i, 0].set_title(f"Kırpılmış {i+1}")
    axes[i, 0].axis("off")

    axes[i, 1].imshow(stretched, cmap='gray')
    axes[i, 1].set_title(f"Kontrast Gerilmiş {i+1}")
    axes[i, 1].axis("off")

    axes[i, 2].imshow(equalized, cmap='gray')
    axes[i, 2].set_title(f"Histogram Eşitlenmiş {i+1}")
    axes[i, 2].axis("off")

plt.tight_layout()
plt.show()

"""# Kontrast Gerilmiş vs. Histogram Eşitlenmiş:
Kontrast Germe (Stretching), minimum ve maksimum piksel değerlerini genişleterek görüntünün kontrastını artırıyor. Bu işlem genellikle mevcut kontrast aralığını tam olarak kullanmayan görüntüler için faydalıdır. Ancak, histogram eşitleme kadar etkili bir şekilde lokal kontrastı artırmaz.

Histogram Eşitleme (Equalization), görüntünün piksel yoğunluk dağılımını dengeleyerek hem parlak hem de koyu alanlarda detayların daha belirgin hale gelmesini sağlıyor. Bu özellikle düşük kontrastlı tıbbi görüntülerde önemli olabilir.

# Gözle Görülebilir Farklar:
Histogram eşitleme ile işlenen görüntüler, genel olarak daha fazla detay içeriyor. Kemik yapıları, damarlar ve doku detayları daha net hale gelmiş.

Kontrast germe işlemi, parlaklık seviyelerini genişletse de, bazı bölgelerde detay kaybına neden olmuş olabilir. Özellikle çok parlak veya çok koyu alanlarda histogram eşitleme daha iyi sonuçlar vermiş gibi görünüyor.

**Histogram eşitleme**, düşük kontrastlı alanlardaki farkları daha belirgin hale getirerek görüntünün genel kalitesini arttırmaktadır.

Bir sonraki adımda Histogram Eşitleme ile devam etme kararı aldım. Bu yöntemin X-ray görüntülerinde daha fazla detay ortaya çıkarması ve kontrastı daha dengeli şekilde iyileştirmektedir.

Kontrast germe işlemi parlaklık aralığını genişletse de, histogram eşitleme tüm görüntüde kontrastı optimize ederek kemik, doku ve damar detaylarını daha belirgin hale getirdi. Ayrıca, düşük kontrastlı bölgelerde detay kaybını önleyerek tıbbi analiz için daha uygun bir sonuç sundu. Bu nedenle, daha net ve dengeli görüntüler elde etmek için Histogram Eşitleme yöntemiyle devam edilecektir.
"""

# Median Blur
def median_blur(image, kernel_size=5):
    return cv2.medianBlur(image, kernel_size)

# Gaussian Blur
def gaussian_blur(image, kernel_size=5):
    return cv2.GaussianBlur(image, (kernel_size, kernel_size), 0)

# Gürültü azaltma işlemleri
filtered_images = [(equalized, median_blur(equalized), gaussian_blur(equalized)) for _, _, equalized in processed_images]

# Görselleştirme
fig, axes = plt.subplots(9, 3, figsize=(15, 38))
for i, (equalized, median_filtered, gaussian_filtered) in enumerate(filtered_images):
    axes[i, 0].imshow(equalized, cmap='gray')
    axes[i, 0].set_title(f"Histogram Eşitlenmiş {i+1}")
    axes[i, 0].axis("off")

    axes[i, 1].imshow(median_filtered, cmap='gray')
    axes[i, 1].set_title(f"Median Blur {i+1}")
    axes[i, 1].axis("off")

    axes[i, 2].imshow(gaussian_filtered, cmap='gray')
    axes[i, 2].set_title(f"Gaussian Blur {i+1}")
    axes[i, 2].axis("off")

plt.tight_layout()
plt.show()

"""Görüntülere bakıldığında Median Blur, Gaussian Blur ile karşılaştırıldığında daha keskin hatlar koruyarak gürültüyü azalttığı görülüyor. Gaussian Blur ise daha fazla bulanıklık ekleyerek bazı detayları kaybettirmiş olabilir.

# Karşılaştırma:
**Median Blur:** Gürültüyü azaltırken kenar detaylarını daha iyi koruyor. Özellikle X-ray görüntüleri gibi kenarların önemli olduğu tıbbi görüntülerde tercih edilmesi daha mantıklı.

**Gaussian Blur:** Daha yumuşak geçişler sağlasa da, bazı kemik yapılarında ve kritik detaylarda bulanıklığa neden olabiliyor.

Bu nedenle, detay kaybını önlemek ve tıbbi analiz açısından daha iyi sonuç almak için Median Blur yöntemiyle devam etmek daha doğru bir yaklaşım olacaktır.

# 4.	Eşik sayısı belirleme

o	Tek eşik değeri kullanacaksanız, Görüntülere Gauss yoğunluk dönüşümü gibi akciğer yoğunluk değerleri ile düşük ve yüksek değerleri ayıracak bir transform uygulayınız.

 ![image.png](data:image/png;base64,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)

o	Dönüşüm uygulanmayacaksa optimum eşik sayısı belirlenmeli bunu dikkate alın. (örnek1: eşik sayısı 2 bölge sayısı 3 (alt-orta-üst)  orta=1, else=0, örnek2:esik sayısı 5, bölge sayısı 6 (a1-a2-o1-o2-u1-u2) o1&o2=1, else=0)
"""

# Sabit eşik değerleri
thresholds = [0, 50, 100, 150, 200, 255]

def threshold_segmentation(image, thresholds):
    segmented_image = np.zeros_like(image, dtype=np.uint8)

    # Bölgelere ayırma işlemi
    for i in range(1, len(thresholds) - 1):
        lower = thresholds[i]
        upper = thresholds[i + 1]

        if i == 2 or i == 3:  # o1 ve o2 bölgeleri için
            segmented_image[(image >= lower) & (image < upper)] = 1
        else:
            segmented_image[(image >= lower) & (image < upper)] = 0

    return segmented_image

# 9 farklı görseli işleme
fig, axes = plt.subplots(9, 2, figsize=(10, 40))

for idx, image_path in enumerate(sampled_images[:9]):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    transformed_image = threshold_segmentation(original_image, thresholds)

    # Görselleştirme
    axes[idx, 0].imshow(original_image, cmap='gray')
    axes[idx, 0].set_title(f'Orijinal Görüntü {idx+1}')
    axes[idx, 0].axis('off')

    axes[idx, 1].imshow(transformed_image, cmap='gray')
    axes[idx, 1].set_title(f'Transform Görüntü {idx+1}')
    axes[idx, 1].axis('off')

plt.tight_layout()
plt.show()

"""Transform görüntülerinde uygulanan eşikleme işlemi, kemik yapılarını belirginleştirmiş ve kaburgalar ile omurgayı net bir şekilde ayrıştırmıştır. Bu durum, medikal analizler için faydalı olabilir. Ancak bazı görüntülerde arka planda istenmeyen siyah ve beyaz alanlar bulunmakta, bu da eşik değerlerinin optimize edilmesi gerektiğini göstermektedir. Özellikle Görüntü 2 ve 6’da daha fazla beyaz alan görülmesi, düşük yoğunluklu bölgelerin yanlış eşiklenmiş olabileceğini düşündürmektedir. Ayrıca, akciğer dokularında bazı anatomik detayların kaybolduğu fark ediliyor. Bu nedenle, daha iyi bir segmentasyon için adaptif eşikleme veya Otsu yöntemi gibi dinamik yaklaşımlar denenebilir.

# 4. Thresholding
1.	Global Thresholding, Otsu veya skimage all filter kütüphanesini kullanarak (from skimage.filters import try_all_threshold) https://scikit-image.org/docs/dev/auto_examples/segmentation/plot_thresholding.html en az 2 thresholding yöntemi  ile eşik değerlerini belirleyiniz.
2.	Eşik değerlerini görüntülere uygulayarak binary görüntüleri görselleştirip uygun thresholding yöntemini i seçiniz. (YORUM)
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu, threshold_mean


fig, axes = plt.subplots(9, 3, figsize=(15, 40))

for idx, image_path in enumerate(sampled_images[:9]):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Global Thresholding
    global_thresh = threshold_mean(original_image)
    binary_global = original_image > global_thresh

    # Otsu thresholding
    otsu_thresh = threshold_otsu(original_image)
    binary_otsu = original_image > otsu_thresh

    # Görselleştirme
    axes[idx, 0].imshow(original_image, cmap='gray')
    axes[idx, 0].set_title(f'Orijinal Görüntü {idx+1}')
    axes[idx, 0].axis('off')

    axes[idx, 1].imshow(binary_global, cmap='gray')
    axes[idx, 1].set_title(f'Global Threshold {global_thresh:.2f}')
    axes[idx, 1].axis('off')

    axes[idx, 2].imshow(binary_otsu, cmap='gray')
    axes[idx, 2].set_title(f'Otsu Threshold {otsu_thresh:.2f}')
    axes[idx, 2].axis('off')

plt.tight_layout()
plt.show()

"""Global Thresholding yönteminde belirlenen eşik değeri sabit olduğu için bazı bölgelerde fazla beyazlık (over-segmentation) veya gereğinden fazla karanlık bölgeler (under-segmentation) oluşmuş. Özellikle aydınlık seviyesinin değişken olduğu X-ray görüntülerinde global thresholding, doku detaylarını kaybedebilir.

Otsu Thresholding, görüntüdeki histogramı analiz ederek optimal bir eşik değeri belirlediği için daha adaptif bir segmentasyon sağlıyor. Çoğu görüntüde Otsu yöntemi daha düşük eşik değerleri belirleyerek ince detayları daha iyi ayırmış gibi görünüyor.

Otsu thresholding, görüntü histogramını analiz ederek en iyi eşik değerini belirler ve farklı ışık koşullarına daha iyi uyum sağlar. Buna karşın, global thresholding sabit bir eşik değeri kullanır ve farklı aydınlatma seviyelerine sahip bölgelerde yanlış segmentasyon yapabilir. Özellikle X-ray gibi tıbbi görüntülerde, ince yapıları korumak ve önemli detayları kaybetmemek için Otsu thresholding daha güvenilir bir yöntemdir. Bundan dolayı Otsu thresholding ile devam edilecektir.

# 3. Post-processing
1.	Uygun morfolojik operatörleri, uygun structural element yapısı ve boyutunu seçerek görüntüye uygulayınız. (YORUM)
o	Giriş ve Çıkış Görüntülerini görseleştirin
.
2.	Görüntüye bağlantı bileşen analizi (connected component labeling-CCL) (cv2.connectedComponents) uygulayarak olası bölge sayısını print CCL çıktısını plot edin.

3.	Elde ettiğiniz labellar için, Centroid ve Area bilgilerinin kesinlikle olacağı, ayrıca bölgelerin yoğunluk ve şekilsel özelliklerini belirten en az 5 tane özniteliği print edin.
o	(cv2.connectedComponentsWithStats önerebilirim ama scikit-image’ın regionprops u daha iyi)
4.	Elde ettiğiniz stats ve labelsları inceleyerek akciğer alanlarını en iyi ifade eden öznitelikleri yorumlayınız.
o	Belirlediğniz özniteliklere göre filtreleme yapın. (örn: maks alana sahip ilk iki bölge, if maks alana sahip iki bölge and bölgelerin centroidleri ortada; filter; else try 3. Bölge; return)
o	Belirleyici öznitelik bulunamadıysa. Her görüntüde otomatik olarak label belirleyen algoritmayı yazın

5.	Seçtiğiniz labela sahip filtrelenmiş görüntülere uygun morfolojik işlemleri (structural elemant tipi ve boyutu belirleyerek) uygulayın. Giriş ve çıkış görüntülerini görselleştirin.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu

# Görseli işleyip morfolojik işlemleri uygulamak
def apply_morphological_operations(image_path):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Otsu Thresholding
    otsu_thresh = threshold_otsu(original_image)
    binary_otsu = original_image > otsu_thresh

    # Morfolojik Operatörler
    kernel = np.ones((5, 5), np.uint8)  # 5x5 boyutunda bir kernel
    morph_open = cv2.morphologyEx(binary_otsu.astype(np.uint8), cv2.MORPH_OPEN, kernel)
    morph_close = cv2.morphologyEx(morph_open, cv2.MORPH_CLOSE, kernel)

    # Görselleştirme
    return original_image, binary_otsu, morph_open, morph_close

# 9 Görsel için işlem yapalım
fig, axes = plt.subplots(9, 4, figsize=(20, 40))

for idx, image_path in enumerate(sampled_images[:9]):
    original_image, binary_otsu, morph_open, morph_close = apply_morphological_operations(image_path)

    # Görselleştirme
    axes[idx, 0].imshow(original_image, cmap='gray')
    axes[idx, 0].set_title(f'Orijinal Görüntü {idx+1}')
    axes[idx, 0].axis('off')

    axes[idx, 1].imshow(binary_otsu, cmap='gray')
    axes[idx, 1].set_title(f'Otsu Thresholding')
    axes[idx, 1].axis('off')

    axes[idx, 2].imshow(morph_open, cmap='gray')
    axes[idx, 2].set_title(f'Açma İşlemi (Opening)')
    axes[idx, 2].axis('off')

    axes[idx, 3].imshow(morph_close, cmap='gray')
    axes[idx, 3].set_title(f'Kapama İşlemi (Closing)')
    axes[idx, 3].axis('off')

plt.tight_layout()
plt.show()

"""**Açma İşlemi (Opening):** Açma işlemi, küçük gürültüleri ve ince bağlantıları ortadan kaldırarak segmentasyonun temizlenmesine yardımcı olmuş. Ancak bazı bölgelerde önemli detayların kaybolduğu gözlemlenebilir. Özellikle küçük beyaz alanlar (örneğin akciğer içindeki detaylar) silinmiş olabilir.

**Kapama İşlemi (Closing):** Kapama işlemi ise daha büyük beyaz alanları birleştirerek boşlukları doldurmuş. Bu, segmentasyon açısından avantajlı olabilir çünkü istenilen nesnenin bütünlüğünü korumaya yardımcı olmuş. Ancak bazı ince detayları kapatarak önemli bilgilerin kaybolmasına neden olabilir.

Kapama işlemi (Closing) daha bütünsel ve temiz bir görüntü oluşturduğu için tercih edilmelidir. Açma işlemi küçük gürültüleri temizlerken bazı önemli detayları kaybettirmiş olabilir. Eğer amaç akciğer alanlarını daha net belirlemekse, kapama işlemi ile devam edilmesi gerekir.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu
from skimage.measure import regionprops

def apply_morphological_operations(image_path):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Otsu Thresholding
    otsu_thresh = threshold_otsu(original_image)
    binary_otsu = original_image > otsu_thresh

    # Morfolojik Operatörler
    kernel = np.ones((5, 5), np.uint8)
    morph_open = cv2.morphologyEx(binary_otsu.astype(np.uint8), cv2.MORPH_OPEN, kernel)
    morph_close = cv2.morphologyEx(morph_open, cv2.MORPH_CLOSE, kernel)

    return original_image, binary_otsu, morph_open, morph_close

def connected_components_analysis(morph_close, original_image):
    # Bağlantı Bileşen Analizi (CCL)
    num_labels, labels = cv2.connectedComponents(morph_close)

    # Görselleştirme
    plt.figure(figsize=(8, 8))
    plt.imshow(labels, cmap='nipy_spectral')
    plt.title(f'CCL - Bölge Sayısı: {num_labels-1}')
    plt.axis('off')
    plt.show()

    print(f"\nBölge Sayısı: {num_labels-1}")

    # RegionProperties kullanarak her bir bölgeyi analiz et
    regions = regionprops(labels, intensity_image=original_image)

    region_data = []
    for region in regions:
        region_data.append({
            'label': region.label,
            'centroid': region.centroid,
            'area': region.area,
            'eccentricity': region.eccentricity,
            'solidity': region.solidity,
            'mean_intensity': region.mean_intensity,
            'orientation': region.orientation
        })

    return num_labels, labels, region_data

for idx, image_path in enumerate(sampled_images[:9]):
    original_image, binary_otsu, morph_open, morph_close = apply_morphological_operations(image_path)

    # Bağlantı Bileşen Analizi ve RegionProperties
    num_labels, labels, region_data = connected_components_analysis(morph_close, original_image)

    # Her bir bölge verisini yazdır
    print(f"Image {idx+1} Region Data:")
    for region in region_data:
        print(f"Label: {region['label']}, Centroid: {region['centroid']}, Area: {region['area']}, "
              f"Eccentricity: {region['eccentricity']}, Solidity: {region['solidity']}, "
              f"Mean Intensity: {region['mean_intensity']}, Orientation: {region['orientation']}, \n")

"""Görüntü işleme ve bilgisayarlı görü alanlarında, özellikle nesne tanıma, segmentasyon ve sınıflandırma gibi görevlerde, her bir bileşeni ayrı olarak ele almak ve bunların özelliklerini incelemek büyük önem taşır. Bağlantı bileşen analizi (CCL) sayesinde, görüntüde birbirinden bağımsız nesneler veya bölgeler etiketlenerek tespit edilir ve her bir bileşenin alanı, konumu, yoğunluğu gibi öznitelikler çıkarılır. Bu öznitelikler, nesnelerin şekilsel özelliklerini anlamak, farklı nesneleri sınıflandırmak veya belirli kriterlere göre filtreleme yapmak için kullanılır. Örneğin, biyomedikal görüntülerde hücreleri saymak, üretim hatlarında nesne tespiti yapmak veya trafik kameralarında araçları belirlemek gibi birçok alanda bu tür analizler kritik rol oynar. Dolayısıyla, bu süreç görüntüdeki bilgi miktarını artırarak, karar verme mekanizmalarına girdi sağlayan bir veri analizi sürecine dönüşür.

Resim 1'de yapılan Bağlantı Bileşen Analizi (CCL) sonucunda 20 farklı bölge tespit edilmiştir. Bu bölgeler arasında en büyük alanı kaplayan Label 1 yaklaşık 910031 piksel büyüklüğündedir ve görüntünün büyük bir kısmını oluşturur. Eksantriklik değeri 0.47 olduğu için nispeten kompakt bir yapıya sahiptir. Ortalama yoğunluğu 183.74 olup, diğer küçük bölgelere kıyasla daha parlak bir yapı göstermektedir. Diğer bölgeler oldukça küçük olup, alanları 25 ile 874 piksel arasında değişmektedir. Eksantriklikleri 0’a yakın olan bölgeler tam yuvarlak bir forma sahiptir, yüksek eksantriklik değerlerine sahip bölgeler ise daha eliptik bir yapı sergilemektedir. Katılık (solidity) değerleri 0.7 ile 1.0 arasında değişmekte, bu da bazı bölgelerin oldukça yoğun ve düzgün, bazılarının ise daha girintili çıkıntılı olduğunu göstermektedir.

Görüntüde bazı bölgeler oldukça parlak olup (örneğin Label 2 ve 3’ün ortalama yoğunluğu yaklaşık 254, yani neredeyse beyazdır), bazı bölgeler ise daha koyu tonlara sahiptir (Label 6, 7, 10, 15 gibi bölgelerin yoğunluk ortalamaları 125-130 civarındadır). Genel yapı itibarıyla simetrik formlar içerdiği için görüntü bir röntgen veya medikal görüntü olabilir. Bununla birlikte, yüksek eksantrikliğe sahip küçük bileşenler segmentasyon hatası veya gürültü kaynaklı olabilir. Segmentasyon kalitesini artırmak için morfolojik işlemlerde kernel boyutu artırılarak küçük ve gereksiz bileşenler temizlenebilir. Ayrıca, çok küçük bileşenleri filtrelemek amacıyla bir alan eşiği belirlenebilir (örneğin, 50 pikselden küçük olanlar hariç tutulabilir). Alternatif olarak, watershed gibi farklı segmentasyon yöntemleri de denenerek daha iyi bileşen ayrımı sağlanabilir.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage.measure import regionprops

# Filtreleme işlemi için kriterler
def filter_regions_by_area_and_centroid(region_data):
    # Alanına göre sıralama
    region_data.sort(key=lambda x: x['area'], reverse=True)

    # Maksimum alana sahip iki bölgeyi seç
    filtered_regions = region_data[:2]

    # İlk iki bölgenin centroidlerinin ortada olup olmadığını kontrol et
    centroids = [region['centroid'] for region in filtered_regions]
    centroids_x = [centroid[0] for centroid in centroids]
    centroids_y = [centroid[1] for centroid in centroids]

    # Eğer centroidler ortada değilse, 3. bölgeyi dene
    if not (min(centroids_x) < np.mean(centroids_x) < max(centroids_x) and
            min(centroids_y) < np.mean(centroids_y) < max(centroids_y)):
        filtered_regions = region_data[:3]  # 3. bölgeyi ekleyelim

    print(f"Filtered Regions (Top by Area & Centroids Check): {[region['label'] for region in filtered_regions]}")

    return filtered_regions

def extract_region_properties(labels, original_image):
    # RegionProperties kullanarak her bir bölgeyi analiz et
    regions = regionprops(labels, intensity_image=original_image)

    region_data = []
    for region in regions:
        region_data.append({
            'label': region.label,
            'centroid': region.centroid,
            'area': region.area,
            'eccentricity': region.eccentricity,
            'solidity': region.solidity,
            'mean_intensity': region.mean_intensity,
            'orientation': region.orientation
        })

    return region_data

def connected_components_analysis(morph_close):
    # Bağlantı Bileşen Analizi (CCL)
    num_labels, labels = cv2.connectedComponents(morph_close)

    return num_labels, labels

# Görselleştirme ve işlemi birleştirelim
for idx, image_path in enumerate(sampled_images[:9]):
    original_image, binary_otsu, morph_open, morph_close = apply_morphological_operations(image_path)
    num_labels, labels = connected_components_analysis(morph_close)
    region_data = extract_region_properties(labels, original_image)

    # Akciğer alanlarını en iyi ifade eden özniteliklere göre filtreleme yap
    filtered_regions = filter_regions_by_area_and_centroid(region_data)

    # Seçilen bölgeleri işaretleyip görselleştirelim
    labeled_image = np.zeros_like(labels)
    for region in filtered_regions:
        labeled_image[labels == region['label']] = region['label']

    # Giriş ve çıkış görüntülerini yan yana görselleştirelim
    plt.figure(figsize=(15, 8))

    # Orijinal morfolojik işlemi yapılmış görüntü
    plt.subplot(1, 2, 1)
    plt.imshow(morph_close, cmap='gray')
    plt.title(f'Morfolojik İşlenmiş Görüntü {idx+1}')
    plt.axis('off')

    # Filtrelenmiş görüntü
    plt.subplot(1, 2, 2)
    plt.imshow(labeled_image, cmap='nipy_spectral')
    plt.title(f'Filtrelenmiş Akciğer Alanları {idx+1}')
    plt.axis('off')

    plt.show()

"""Filtreleme, görüntü işleme süreçlerinde belirli nesneleri veya bölgeleri ayırt etmek ve istenmeyen parçaları elemine etmek için kullanılır. Akciğer görüntüleri üzerinde yapılan filtreleme işlemi, akciğer dokusunu çevreleyen diğer anatomik yapılar veya gürültüden ayırarak net bir segmentasyon sağlamak amacıyla gerçekleştirilir. Bu sayede, analiz edilecek alanın daha doğru belirlenmesi ve modelin yalnızca ilgili bölgeler üzerinde çalışması sağlanır. Özellikle tıbbi görüntü analizinde, akciğer gibi belirli organları hedefleyerek doğru teşhis ve değerlendirme yapmak için filtreleme kritik bir adımdır.

Filtreleme sonucunda elde edilen akciğer alanları genellikle başarılı bir şekilde belirlenmiş, çoğu görselde iki büyük bölge seçilmiş. Görsel 1, 2, 7 ve 9 gibi örneklerde akciğer lobları net bir şekilde ayrılmışken, Görsel 8’de yalnızca bir bölgenin seçilmesi segmentasyon sürecinde bir eksiklik olduğunu gösteriyor. Görsel 3, 4 ve 6’da, seçilen ikinci bölgenin gerçekten akciğer olup olmadığı sorgulanabilir. Görsel 5 ve 6’da ise bazı dış kısımlar da filtreleme sonucu dahil olmuş olabilir.
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

def apply_morphological_operations(filtered_image):
    # Yapısal eleman seçimi (açma ve kapama için)
    kernel = np.ones((5, 5), np.uint8)  # 5x5 boyutunda kare bir yapı elemanı

    # Açma (Opening) işlemi
    morph_open = cv2.morphologyEx(filtered_image, cv2.MORPH_OPEN, kernel)

    # Kapama (Closing) işlemi
    morph_close = cv2.morphologyEx(filtered_image, cv2.MORPH_CLOSE, kernel)

    return morph_open, morph_close


for idx, image_path in enumerate(sampled_images[:9]):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)


    _, binary_otsu = cv2.threshold(original_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)


    filtered_image = np.zeros_like(binary_otsu)
    num_labels, labels = connected_components_analysis(binary_otsu)
    region_data = extract_region_properties(labels, original_image)
    filtered_regions = filter_regions_by_area_and_centroid(region_data)


    for region in filtered_regions:
        filtered_image[labels == region['label']] = 255

    # Morfolojik işlemler (açma ve kapama)
    morph_open_filtered, morph_close_filtered = apply_morphological_operations(filtered_image)
    plt.figure(figsize=(15, 8))

    # Orijinal morfolojik işlemli görüntü
    plt.subplot(1, 2, 1)
    plt.imshow(filtered_image, cmap='gray')
    plt.title(f'Filtrelenmiş Görüntü {idx+1}')
    plt.axis('off')

    # Morfolojik işlem yapılmış (kapama) görüntü
    plt.subplot(1, 2, 2)
    plt.imshow(morph_close_filtered, cmap='gray')
    plt.title(f'Morfolojik İşlemli Görüntü {idx+1}')
    plt.axis('off')

    plt.show()

"""Filtrelenmiş akciğer görüntülerine uygun morfolojik işlemler uygulandı. Bu süreçte, açma (opening) ve kapama (closing) işlemleri için kare şeklinde 5x5 boyutunda bir yapı elemanı (structural element) kullanıldı. Açma işlemi, küçük gürültüleri ve istenmeyen küçük nesneleri temizlemek için kullanılırken, kapama işlemi akciğer sınırlarını daha belirgin hale getirmek ve boşlukları doldurmak için uygulandı.


Morfolojik işlemler sonrası elde edilen görüntülerde, akciğer alanlarının sınırları daha düzgün ve net bir şekilde ortaya çıktı. Önceki filtreleme aşamasında bazı küçük parçalar hala mevcutken, açma işlemi bu parçaları temizlemeye yardımcı oldu. Kapama işlemi ise akciğerlerin içindeki kesintili bölgeleri birleştirerek daha bütüncül bir yapı oluşturdu.

Görselleri incelediğimizde, bazı görüntülerde hala küçük kayıpların olabileceği ancak genel olarak akciğer alanlarının belirgin hale geldiği gözlemlendi. Bu süreç, özellikle akciğer bölgesini vurgulamak ve tıbbi analizlerde segmentasyon doğruluğunu artırmak için önemli bir adımdır.
"""

def apply_morphological_operations(filtered_image):

    kernel = np.ones((5, 5), np.uint8)

    # Açma (Opening) işlemi
    morph_open = cv2.morphologyEx(filtered_image, cv2.MORPH_OPEN, kernel)

    # Kapama (Closing) işlemi
    morph_close = cv2.morphologyEx(filtered_image, cv2.MORPH_CLOSE, kernel)

    return morph_open, morph_close

for idx, image_path in enumerate(sampled_images[:9]):
    original_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)


    _, binary_otsu = cv2.threshold(original_image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)


    filtered_image = np.zeros_like(binary_otsu)
    num_labels, labels = connected_components_analysis(binary_otsu)
    region_data = extract_region_properties(labels, original_image)
    filtered_regions = filter_regions_by_area_and_centroid(region_data)


    for region in filtered_regions:
        filtered_image[labels == region['label']] = 255

    # Morfolojik işlemler (açma ve kapama)
    morph_open_filtered, morph_close_filtered = apply_morphological_operations(filtered_image)

    # Maske ile orijinal görüntüyü çarpma (maskelenmiş görüntü)
    masked_image = cv2.bitwise_and(original_image, original_image, mask=morph_close_filtered)


    plt.figure(figsize=(25, 15))

    # Orijinal Görüntü
    plt.subplot(1, 3, 1)
    plt.imshow(original_image, cmap='gray')
    plt.title(f'Orijinal Görüntü {idx+1}')
    plt.axis('off')

    # Morfolojik işlem uygulanmış çıkış görüntüsü
    plt.subplot(1, 3, 2)
    plt.imshow(morph_close_filtered, cmap='gray')
    plt.title(f'Morfolojik İşlemli Görüntü {idx+1}')
    plt.axis('off')

    # Maskelenmiş Görüntü
    plt.subplot(1, 3, 3)
    plt.imshow(masked_image, cmap='gray')
    plt.title(f'Maskelenmiş Görüntü {idx+1}')
    plt.axis('off')

    plt.show()

"""Görsel 1 (Filtered Regions: [3, 252])
Morfolojik işlem sonucunda akciğer alanları iyi şekilde ayrıştırılmış ve maskelenmiş alanda belirginleşmiş. Orijinal görüntüdeki çok fazla detay kaybolmuş ve netleşmiş olan alanlar daha belirgin bir şekilde ortaya çıkmış.

Görsel 2 (Filtered Regions: [3, 10])
Bu görselde morfolojik işlem sonrası maskede daha fazla boşluk ve izlenim var. Akciğer yapılarının netliği orijinal görsele kıyasla azalmış. Maskelenmiş bölgede büyük yapıların vurgulanması sağlanmış.

Görsel 3 (Filtered Regions: [4, 552])
Morfolojik işlem sonrası akciğerler net bir şekilde ayrılmış ve maskelenmiş görüntüde bu bölgeler çok belirgin. Ancak bazı kenar bölgelerinde hafif belirsizlikler olabilir. Çalışılan alan oldukça temiz ve iyi bir şekilde maskelenmiş.

Görsel 4 (Filtered Regions: [1, 295])
Bu görselde maskelenmiş alan büyük ölçüde orijinal görsele sadık kalmış. Morfolojik işlem sonrasında oldukça temiz bir görüntü elde edilmiş. Ancak, bazı ince detaylar kaybolmuş olabilir. Maskedeki ayrıntıların çoğu, akciğerlerin temel yapısını yeterince belirgin kılıyor.

Görsel 5 (Filtered Regions: [3, 2])
Bu görüntüde büyük ölçüde boş alanlar ortaya çıkmış ve akciğer yapıları maskelenmiş görüntüde daha net. Bununla birlikte, görüntüdeki çok ince ayrıntılar kaybolmuş olabilir. Maskelenmiş bölgede daha büyük yapıların vurgulandığı gözlemleniyor.

Görsel 6 (Filtered Regions: [3, 292])
Bu görselde morfolojik işlem sonrasında akciğer yapıları net bir şekilde ayırt edilebiliyor ve maskelenmiş görüntüde belirgin hale geliyor. Morfolojik işlemler, orijinal görüntüye benzer bir yapıyı korurken gereksiz arka planları da temizlemiş.

Görsel 7 (Filtered Regions: [1, 907])
Maskelenmiş görüntüdeki büyük akciğer yapıları net bir şekilde görünürken, bazı küçük bölgelerde detay kaybı yaşanmış. Ancak genel olarak akciğer bölgesinin ayırt edilebilirliği yüksek.

Görsel 8 (Filtered Regions: [1, 83])
Bu görselde morfolojik işlem sonrası maskelenmiş görüntü oldukça belirgin hale gelmiş. Akciğerler ve çevresindeki yapılar daha iyi ayrılmış, fakat orijinal görseldeki bazı ince detaylar kaybolmuş olabilir. Maskelenmiş görüntüdeki netlik başarılı bir şekilde sağlanmış.

Görsel 9 (Filtered Regions: [2, 50])
Bu görüntüde morfolojik işlem sonrasında maskelenmiş bölge oldukça belirginleşmiş. Akciğer yapıları daha açık bir şekilde ortaya çıkmış, ancak bazı ince ayrıntılar kaybolmuş olabilir. Maskelenmiş görüntüdeki vurgulanan alanlar orijinal görseldeki önemli yapıları oldukça iyi temsil ediyor.

Her bir görüntüde morfolojik işlemlerin başarılı olduğu ve akciğer bölgelerinin çoğunlukla net bir şekilde ayrıldığı gözlemleniyor. Ancak, maskelenmiş görüntülerde bazı ince detayların kaybolduğu ve küçük bölgelerde belirsizliklerin oluştuğu görülüyor. Bu tür maskeler, akciğerlerin daha net bir şekilde izole edilmesi için yararlı olabilir, fakat görüntüdeki küçük yapılar için daha ince morfolojik işlemler gerekebilir.
"""